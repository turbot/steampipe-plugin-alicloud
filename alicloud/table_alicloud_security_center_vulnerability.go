package alicloud

import (
	"context"
	"fmt"
	"slices"
	"strconv"

	"github.com/aliyun/alibaba-cloud-sdk-go/sdk/requests"
	"github.com/aliyun/alibaba-cloud-sdk-go/services/sas"
	"github.com/turbot/steampipe-plugin-sdk/v5/grpc/proto"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin"
	"github.com/turbot/steampipe-plugin-sdk/v5/plugin/transform"
)

//// TABLE DEFINITION

func tableAlicloudSecurityCenterVulnerability(ctx context.Context) *plugin.Table {
	return &plugin.Table{
		Name:        "alicloud_security_center_vulnerability",
		Description: "Alicloud Security Center Vulnerabilities",
		List: &plugin.ListConfig{
			Hydrate: listSecurityCenterVulnerabilities,
			Tags:    map[string]string{"service": "sas", "action": "DescribeVulList"},
			KeyColumns: []*plugin.KeyColumn{
				{Name: "instance_id", Require: plugin.Optional},
				{Name: "status", Require: plugin.Optional},
				{Name: "type", Require: plugin.Optional},
				{Name: "level", Require: plugin.Optional},
			},
		},
		GetMatrixItemFunc: BuildRegionList,
		Columns: []*plugin.Column{
			{
				Name:        "name",
				Type:        proto.ColumnType_STRING,
				Description: "The name of the vulnerability.",
				Transform:   transform.FromField("Name"),
			},
			{
				Name:        "alias_name",
				Type:        proto.ColumnType_STRING,
				Description: "The alias name of the vulnerability.",
			},
			{
				Name:        "record_id",
				Type:        proto.ColumnType_INT,
				Description: "The ID of the vulnerability record.",
				Transform:   transform.FromField("RecordId").Transform(int64ToInt),
			},
			{
				Name:        "primary_id",
				Type:        proto.ColumnType_INT,
				Description: "The primary ID of the vulnerability.",
				Transform:   transform.FromField("PrimaryId").Transform(int64ToInt),
			},
			{
				Name:        "instance_id",
				Type:        proto.ColumnType_STRING,
				Description: "The ID of the ECS instance affected by the vulnerability.",
			},
			{
				Name:        "instance_name",
				Type:        proto.ColumnType_STRING,
				Description: "The name of the ECS instance affected by the vulnerability.",
			},
			{
				Name:        "uuid",
				Type:        proto.ColumnType_STRING,
				Description: "The UUID of the asset affected by the vulnerability.",
			},
			{
				Name:        "type",
				Type:        proto.ColumnType_STRING,
				Description: "The type of vulnerability (e.g., cve, sys, app).",
			},
			{
				Name:        "level",
				Type:        proto.ColumnType_STRING,
				Description: "The severity level of the vulnerability (e.g., high, medium, low).",
			},
			{
				Name:        "status",
				Type:        proto.ColumnType_INT,
				Description: "The status of the vulnerability. 0: unfixed, 1: fixed, 2: verifying, 3: ignored.",
				Transform:   transform.FromField("Status").Transform(int64ToInt),
			},
			{
				Name:        "can_fix",
				Type:        proto.ColumnType_STRING,
				Description: "Indicates whether the vulnerability can be fixed.",
			},
			{
				Name:        "can_update",
				Type:        proto.ColumnType_BOOL,
				Description: "Indicates whether the vulnerability can be updated.",
			},
			{
				Name:        "necessity",
				Type:        proto.ColumnType_STRING,
				Description: "The necessity level of fixing the vulnerability.",
			},
			{
				Name:        "need_reboot",
				Type:        proto.ColumnType_STRING,
				Description: "Indicates whether a reboot is needed after fixing.",
			},
			{
				Name:        "os_name",
				Type:        proto.ColumnType_STRING,
				Description: "The operating system name of the affected instance.",
			},
			{
				Name:        "os_version",
				Type:        proto.ColumnType_STRING,
				Description: "The operating system version of the affected instance.",
			},
			{
				Name:        "ip",
				Type:        proto.ColumnType_STRING,
				Description: "The IP address of the affected instance.",
			},
			{
				Name:        "internet_ip",
				Type:        proto.ColumnType_STRING,
				Description: "The internet IP address of the affected instance.",
			},
			{
				Name:        "intranet_ip",
				Type:        proto.ColumnType_STRING,
				Description: "The intranet IP address of the affected instance.",
			},
			{
				Name:        "first_ts",
				Type:        proto.ColumnType_TIMESTAMP,
				Description: "The time when the vulnerability was first detected.",
				Transform:   transform.FromField("FirstTs").Transform(transform.UnixToTimestamp),
			},
			{
				Name:        "last_ts",
				Type:        proto.ColumnType_TIMESTAMP,
				Description: "The time when the vulnerability was last detected.",
				Transform:   transform.FromField("LastTs").Transform(transform.UnixToTimestamp),
			},
			{
				Name:        "modify_ts",
				Type:        proto.ColumnType_TIMESTAMP,
				Description: "The time when the vulnerability record was last modified.",
				Transform:   transform.FromField("ModifyTs").Transform(transform.UnixToTimestamp),
			},
			{
				Name:        "repair_ts",
				Type:        proto.ColumnType_TIMESTAMP,
				Description: "The time when the vulnerability was repaired.",
				Transform:   transform.FromField("RepairTs").Transform(transform.UnixToTimestamp),
			},
			{
				Name:        "progress",
				Type:        proto.ColumnType_INT,
				Description: "The progress of fixing the vulnerability (0-100).",
				Transform:   transform.FromField("Progress").Transform(int64ToInt),
			},
			{
				Name:        "result_code",
				Type:        proto.ColumnType_STRING,
				Description: "The result code of the vulnerability fix operation.",
			},
			{
				Name:        "result_message",
				Type:        proto.ColumnType_STRING,
				Description: "The result message of the vulnerability fix operation.",
			},
			{
				Name:        "tag",
				Type:        proto.ColumnType_STRING,
				Description: "The tag of the vulnerability.",
			},
			{
				Name:        "related",
				Type:        proto.ColumnType_STRING,
				Description: "Related information about the vulnerability.",
			},
			{
				Name:        "extend_content_json",
				Type:        proto.ColumnType_JSON,
				Description: "Extended content in JSON format.",
				Transform:   transform.FromField("ExtendContentJson"),
			},

			// Steampipe standard columns
			{
				Name:        "title",
				Type:        proto.ColumnType_STRING,
				Description: ColumnDescriptionTitle,
				Transform:   transform.FromField("Name"),
			},
			{
				Name:        "akas",
				Type:        proto.ColumnType_JSON,
				Description: ColumnDescriptionAkas,
				Hydrate:     getSecurityCenterVulnerabilityAkas,
				Transform:   transform.FromValue(),
			},

			// Alicloud standard columns
			{
				Name:        "region",
				Description: ColumnDescriptionRegion,
				Type:        proto.ColumnType_STRING,
				Hydrate:     getSecurityCenterVulnerabilityRegion,
				Transform:   transform.FromValue(),
			},
			{
				Name:        "account_id",
				Description: ColumnDescriptionAccount,
				Type:        proto.ColumnType_STRING,
				Hydrate:     getCommonColumns,
				Transform:   transform.FromField("AccountID"),
			},
		},
	}
}

//// LIST FUNCTION

func listSecurityCenterVulnerabilities(ctx context.Context, d *plugin.QueryData, _ *plugin.HydrateData) (interface{}, error) {
	region := d.EqualsQualString(matrixKeyRegion)

	// supported regions for security center are International(cn-hangzhou), Malaysia(ap-southeast-3) and Singapore(ap-southeast-1)
	supportedRegions := []string{"cn-hangzhou", "ap-southeast-1", "ap-southeast-3"}
	if !slices.Contains(supportedRegions, region) {
		return nil, nil
	}

	// Create service connection
	client, err := SecurityCenterService(ctx, d, region)
	if err != nil {
		plugin.Logger(ctx).Error("alicloud_listSecurityCenterVulnerabilities", "connection_error", err)
		return nil, err
	}

	// Type is mandatory for DescribeVulList API
	// Common types: "cve" (CVE vulnerabilities), "sys" (system vulnerabilities), "app" (application vulnerabilities)
	// If type is not specified, we'll query all types by making multiple requests
	vulTypes := []string{"cve", "sys", "app"}
	if d.EqualsQualString("type") != "" {
		vulTypes = []string{d.EqualsQualString("type")}
	}

	// Handle status filter - it's an INT column, so we need to handle both int and string
	// Only apply filter if explicitly provided in the query
	// Note: We need to check if qualifier was provided, not if value != 0, because status=0 (unfixed) is a valid filter
	var statusFilter string
	if qualValue := d.EqualsQuals["status"]; qualValue != nil {
		// Check if qualifier was explicitly provided by checking d.Quals
		// This allows us to distinguish between "not provided" and "provided as 0"
		if d.Quals["status"] != nil && len(d.Quals["status"].Quals) > 0 {
			// If qualifier exists, use the value even if it's 0
			// We check d.Quals to ensure the qualifier was explicitly provided
			if d.Quals["status"].Quals[0].Value != nil {
				// Get value from the qual directly to handle status=0
				qualIntVal := d.Quals["status"].Quals[0].Value.GetInt64Value()
				statusFilter = strconv.FormatInt(qualIntVal, 10)
			} else if strVal := qualValue.GetStringValue(); strVal != "" {
				// Fallback to string
				statusFilter = strVal
			}
		}
	}

	// Query each vulnerability type
	for _, vulType := range vulTypes {
		request := sas.CreateDescribeVulListRequest()
		request.Scheme = "https"
		request.Type = vulType // Type is mandatory
		request.PageSize = requests.NewInteger(50)
		request.CurrentPage = requests.NewInteger(1)
		// Only set StatusList if filter was provided
		if statusFilter != "" {
			request.StatusList = statusFilter
		}

		// Apply filters if provided
		if d.EqualsQualString("instance_id") != "" {
			request.Uuids = d.EqualsQualString("instance_id")
		}
		if d.EqualsQualString("level") != "" {
			request.Level = d.EqualsQualString("level")
		}

		count := 0
		for {
			d.WaitForListRateLimit(ctx)
			response, err := client.DescribeVulList(request)
			if err != nil {
				plugin.Logger(ctx).Error("alicloud_listSecurityCenterVulnerabilities", "query_error", err, "request", request, "type", vulType)
				// Continue with next type instead of returning error
				break
			}

			for _, vul := range response.VulRecords {
				vulCopy := vul
				d.StreamListItem(ctx, &vulCopy)
				count++
				if d.RowsRemaining(ctx) == 0 {
					return nil, nil
				}
			}

			pageSize := 50
			if len(response.VulRecords) < pageSize || count >= response.TotalCount {
				break
			}

			// Get current page number from response and increment
			currentPage := response.CurrentPage + 1
			request.CurrentPage = requests.NewInteger(currentPage)
		}
	}

	return nil, nil
}

//// HYDRATE FUNCTIONS

func getSecurityCenterVulnerabilityAkas(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	plugin.Logger(ctx).Trace("getSecurityCenterVulnerabilityAkas")

	data := h.Item.(*sas.VulRecord)
	region := d.EqualsQualString(matrixKeyRegion)

	getCommonColumnsCached := plugin.HydrateFunc(getCommonColumns).WithCache()
	commonData, err := getCommonColumnsCached(ctx, d, h)
	if err != nil {
		return nil, err
	}
	commonColumnData := commonData.(*alicloudCommonColumnData)
	accountID := commonColumnData.AccountID

	akas := []string{"arn:acs:security-center:" + region + ":" + accountID + ":vulnerability/" + strconv.FormatInt(data.RecordId, 10)}
	return akas, nil
}

func getSecurityCenterVulnerabilityRegion(ctx context.Context, d *plugin.QueryData, h *plugin.HydrateData) (interface{}, error) {
	region := d.EqualsQualString(matrixKeyRegion)
	return region, nil
}

//// TRANSFORMS

// int64ToInt converts int64 to int for Steampipe columns
func int64ToInt(ctx context.Context, d *transform.TransformData) (interface{}, error) {
	switch v := d.Value.(type) {
	case int:
		return v, nil
	case int64:
		return int(v), nil
	case int32:
		return int(v), nil
	default:
		plugin.Logger(ctx).Warn("int64ToInt", "unexpected_type", fmt.Sprintf("%T", v), "value", v)
		return 0, nil
	}
}
